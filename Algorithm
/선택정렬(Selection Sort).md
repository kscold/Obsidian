
선택 정렬은 우리가 일상에서 무언가를 크기 순으로 나열할 때 흔히 사용되는 사고 방식과 유사하다.

```text
170cm, 180cm, 150cm, 160cm
```

예를 들어, 위와 같이 키를 알고 있는 네 친구들을 키 순으로 세우려면, 우선 4명의 키를 모두 비교하여 키가 제일 작은 `150cm`인 친구를 맨 앞에 세웁니다.

```text
150cm (4명 중 제일 작음)
```

키가 `150cm`인 친구는 맨 앞에 세웠으니, 이제 나머지 세 친구의 키를 비교하여 키가 제일 작은 `160cm`인 친구를 그 다음에 세웁니다.

```text
150cm, 160cm (150cm 빼고 남은 3명 중 제일 작음)
```

이제는 키가 `170cm`인 친구와 `180cm`인 친구 둘만 남았습니다. 둘 중에 `170cm` 친구가 더 작기 때문에 이 친구를 먼저 세우고, 그 다음 `180cm`인 친구를 마지막에 세웁니다.

```text
150cm, 160cm, 170cm (150cm, 160cm 빼고 남은 2명 중 제일 작음), 180cm (키기 가장 큼)
```

위에서 설명 정렬 방식을 일반해보면 다음과 같이 정리할 수 있습니다.


|Index|Value|
|---|---|
|0|모든 값 중에서 가장 작은 값|
|1|첫번째 값(Index=0)을 제외하고 남은 값 중에서 가장 작은 값|
|…|…|
|i|i번째 부터 n-1 번째까지 값 중 가장 작은 값|
|…|…|
|n-2|n-2번째와 n-1 번째까지 값 중 가장 작은 값|
|n-1|마지막에 남은 하나의 값 (비교 대상 없음)|

즉, 크기 n의 배열이 주어졌을 때, index 0부터 n-1까지의 모든 index i에 대해서, i번째 부터 n-1 번째까지 값 중 가장 작은 값을 구해서 index i에 놓으면 정렬된 배열을 얻을 수가 있습니다. 모든 index에 대해서 그 index에 위치시킬 값을 “선택”하기 때문에 이 정렬 알고리즘을 “선택 정렬”또는 “Selection Sort”이라고 부른다.


아래와 같이 `1`부터 `5`까지 총 5개의 숫자가 들어있는 배열을 위에서 설명한 선택 정렬 알고리즘을 이용하여 정렬을 해보겠습니다. i는 현재 index, m은 가장 작은 값이 있는 index를 가르킵니다.

```py
 i
[3, 4, 5, 1, 2]
          m
```

우선 index 0에 놓을 값을 찾아야 합니다. 모든 숫자 중 가장 작은 숫자인 `1`을 index 3에서 찾았습니다. `1`을 index 0에 위치시키기 위해서 위해서 원래 index 0에 있던 `3`과 `1`의 자리를 바꿉니다.

```py
    i
[1, 4, 5, 3, 2]
             m
```

다음으로 index 1에 놓을 값을 찾아야 합니다. `1`을 제외하고 남은 숫자 중에서 가장 작은 숫자인 `2`를 index 4에서 찾았습니다. `2`를 index 1에 위치시키기 위해서 원래 index 1에 있던 `4`와 `2`의 자리를 바꿉니다.

```py
       i
[1, 2, 5, 3, 4]
          m
```

다음으로 index 2에 놓을 값을 찾아야 합니다. `1`, `2`를 제외하고 남은 숫자 중에서 가장 작은 숫자인 `3`를 index 3에서 찾았습니다. `3`를 index 2에 위치시키기 위해서 원래 index 2에 있던 `5`와 `3`의 자리를 바꿉니다.

```py
          i
[1, 2, 3, 5, 4]
             m
```

다음으로 index 3에 놓을 값을 찾아야 합니다. `1`, `2`, `3`를 제외하고 남은 숫자 중에서 가장 작은 숫자인 `4`를 index 4에서 찾았습니다. `4`를 index 3에 위치시키기 위해서 원래 index 3에 있던 `5`와 `4`의 자리를 바꿉니다.

```py
             i
[1, 2, 3, 4, 5]
             m
```

마지막으로 index 4에 놓을 값을 찾아야 합니다. `1`, `2`, `3`, `4`를 제외한 남은 숫자는 `5` 밖에 없으며 따라서 지동으로 `5`가 가장 작은 숫자가 됩니다.

- 선택 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 `O(1)`의 공간 복잡도를 가집니다.
- 시간 복잡도는 우선 루프문을 통해 모든 인덱스에 접근해야 하기 때문에 기본적으로 `O(N)`을 시간을 소모하며, 하나의 루프에서는 현재 인덱스의 값과 다른 인덱스의 값들과 비교하여 최소값을 찾은 후 현재 인덱스에 있는 값과 상호 자리 교대를(swap)해야 해야하기 때문에 `O(N)`을 시간이 필요하게 됩니다. 따라서 선택 정렬은 총 `O(N^2)`의 시간 복잡도를 가지는 정렬 알고리즘입니다.


- 선택 정렬은 정렬된 값을 배열의 맨 앞부터 하나씩 채워나가게 됩니다. 따라서, 뒤에 있는 index로 갈수록 비교 범위가 하나씩 점점 줄어드는 특성을 가지고 있습니다. (index 0에서는 0부터 n-1까지 비교해야 되지만, index n-1에서는 남은 숫자가 하나 밖어서 비교가 필요 없음)
- 입력 배열이 이미 정렬되어 있건 말건 관계없이 동일한 연산량을 가지고 있기 때문에 최적화 여자가 적어서 다른 `O(N^2)` 대비해도 성능이 떨어지는 편입니다.
- 이러한 성능 상의 한계 때문에 실전에서는 거의 보기 힘들지만, 가장 구현이 쉬운 정렬 알고리즘이라서, 알고리즘 수업 시간에는 한 번씩 꼭 접하게 되는 유명한 정렬 알고리즘입니다.