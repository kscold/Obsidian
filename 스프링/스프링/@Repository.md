@Contoller 어노테이션을 붙이면 핸들러가 스캔할 수 있는 빈(Bean) 객체가 되어 서블릿용 컨테이너에 생성됩니다. 마찬가지로 @Repository, @service 어노테이션은 해당 클래스를 루트 컨테이너에 빈(Bean) 객체로 생성해주는 어노테이션입니다.

둘 다 Bean 객체를 생성해주고 딱히 다른 기능을 넣어주는게 아니라서 뭘 써도 상관 없긴한데 명시적으로 구분해주기 위해 각자 분리해서 사용합니다. 부모 어노테이션인 @Component를 붙여줘도 똑같이 루트 컨테이너에 생성되지만 가시성이 떨어지기 때문에 잘 사용하지 않습니다.

참고로 객체 내에서 데이터 변경 작업이 있는 VO(DTO) 객체와 같은 경우는 동기화 문제로 인해 Bean 객체로 사용하지 않습니다. Bean 객체는 항상 데이터 변경이 없는 객체에 한해 사용하는 점에 유의해야 합니다.

- 컨트롤러 : @Controller (프레젠테이션 레이어, 웹 요청과 응답을 처리함)
- 로직 처리 : @Service (서비스 레이어, 내부에서 자바 로직을 처리함)
- 외부I/O 처리 : @Repository (퍼시스턴스 레이어, DB나 파일같은 외부 I/O 작업을 처리함)

---

루트 컨테이너 또는 서블릿용 컨테이너를 생성할 때 어노테이션을 검색하기 때문에, 컨테이너 생성 시 참조하는 xml 파일에 아래와 같은 어노테이션 스캔 설정이 존재해야 합니다.

```
<!-- 빈(Bean) 생성 및 의존성 주입 어노테이션 스캔 -->
<context:component-scan base-package="패지지 경로" />
```

간단한 사용 예시입니다. DB처리를 할 DAO 클래스를 작성한 뒤, @Repository 어노테이션을 붙여줍니다. 확실하게 하고 싶으면 괄호안에 Bean ID에 해당하는 이름을 붙여줘도 됩니다.

```
@Repository("userDAO")
public class UserDAO {
```

이렇게 해두면 이제 이 클래스는 루트 컨테이너에 빈(Bean) 객체로 생성됩니다. DB 작업을 위해 이 DAO 객체를 불러오려면 new를 이용해 생성하면 안되고 컨테이너에서 받아와야 합니다. 루트 컨테이너의 객체는 어디서든 공유가능하기 때문에, 아래와 같이 자동 의존성 주입(DI) 어노테이션을 이용해 객체를 받아올 수 있습니다.

이 어노테이션들은 같은 빈(Bean) 객체에서만 작동하는 것이기 때문에 Bean으로 만들지 않은 일반 클래스에서 사용해봤자 아무 소용 없습니다. 하지만 일부 DTO객체 등 데이터 변경 작업을 동반하는 클래스 외, 로직을 가진 클래스들은 대부분 @Service 어노테이션을 통해 Bean 객체로 등록해주므로 크게 문제될 일은 없습니다.

자동 의존성 주입 어노테이션(@Resource, @Inject, @Autowired)에 대해서는 아래 링크를 참조하시면 됩니다.

[[Spring MVC/- 기본 문법] - @Resource, @Inject, @Autowired 사용 (자동 의존성 주입)](https://codevang.tistory.com/256)

```
	@Resource(name="userDAO")
	private UserDAO dao;
```