- 삽입 정렬은 [[선택 정렬(Selection Sort)]]처럼 동작 원리를 직관적으로 이해하기 쉬운 알고리즘이다.
- 물론 삽입 정렬은 [[선택 정렬(Selection Sort)]]에 비 구현 난이도가 높은 편이지만 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘이다.

- 삽입 정렬은 특정한 데이터를 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어있다고 가정한다.
- 정렬되어 있는 데이터 [[리스트(List)]]에 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.

## 삽입 정렬의 알고리즘

- 삽입 정렬은 두 번째 데이터부터 시작한다.
- 왜냐하면 첫 번째 데이터는 그자체로 정렬되어 있다고 판단하기 때문이다.

```python
[7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
```

- 위와 같은 리스트가 있다고 가정했을 때, 첫번째 데이터 7은 그 자체로 정렬되어 있다고 판단하고 두 번째 데이터인 5가 어떤 위치에 들어갈지 판단한다.
- 7의 왼쪽으로 들어가거나 혹은 오른쪽으로 들어가는 두 경우만 존재한다.(오름차순으로 정렬하고 싶기 때문에 7의 왼쪽에 넣도록한다.)

```python
[5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
```

- 이어서 9가 어떤 위치에 들어갈지 판단한다.
- 삽입될 수 있는 위치는 총 3가지이며 현재는 5 , 7,  9 순서로 잘 구현되어 있기 때문에 그대로 둔다.

```python
[5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
```

- 이어서 0이 어떤 위치에 들어갈지 판단한다.
- 0은 5, 7, 9와 비교했을 때 가장 작기 때문에, 첫 번째 위치에 삽입한다.

```python
[0, 5, 7, 9, 3, 1, 6, 2, 4, 8]
```

- 위와 같은 삽입 과정을 N-1번 반복하게 되면 모든 데이터가 정렬이된다.
- 또한 삽입정렬의 특징으로 인덱스가 이동할때 그 전 인덱스까지는 항상 정렬되어 있는 상태인데, 삽입될 데이터가 특정한 데이터의 왼쪽에 있는 데이터들은 이미 정렬이 된 상태이기 때문에 자기보다 작은 데이터를 만났다면 더 이상 데이터를 살펴볼 필요없이 그 자리에 삽입하면 된다.

## 삽입 정렬의 시간복잡도

- 삽입 정렬의 시간복잡도는 O(N^2)인데 [[선택 정렬(Selection Sort)]]과 마찬가지로 반복문이 2번 중첩되어 사용되었다.
- 삽입 정렬의 특징으로 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점이다.
- 최선의 경우 O(N)의 시간복잡도를 가진다.