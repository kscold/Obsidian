- [[그래프(Graphs)]]의 각 노드에 인접한 노드들을 연결리스트(Linked List)로 표현하는 방법이다.
- 실제로 가장 많이 쓰이고 노드 중심으로 도는 알고리즘이 많기 때문에 중요하다.
- 노드 중심으로 값과 연결성을 보여주기 때문에 빈 공간이 없어 복잡도가 낮다.
- 배열로 표현하기 때문에 배열의 장점인 인덱스로 접근이 가능하다.


즉, 노드의 개수만큼 인접리스트가 존재하며, 각각의 인접리스트에는 인접한 노드 정보가 저장된다. 그래프는 각 인접리스트에 대한 헤드포인터를 배열로 갖는다.

- 헤드포인터: 연결 리스트의 맨 처음 노드를 가리키는 포인터


![[Pasted image 20230919232038.png]]

- 밑의 코드는 인접리스트를 표현하는 예시로 가중치가 있는 유향 그래프를 만드는 방법이다.
```python
# 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현  
graph = [[] for _ in range(3)]  
  
# 노드 0에 연결된 노드 정보 저장(노드, 거리)  
graph[0].append((1, 7))  # 0과 이어진 left 1 data와 weight 7graph[0].append((2, 5))  # 0과 이어진 right 2 data와 weight 5  
# 노드 1에 연결된 노드 정보 저장(노드, 거리)  
graph[1].append((0, 7))  
  
# 노드 2에 연결된 노드 정보 저장(노드, 거리)  
graph[2].append((0, 5))  
  
print(graph)
```


가중치가 없는 [[무방향 그래프(Undirected graph)]]
: 그림과 같이 가중치 표현 없이 인접한 노드 정보가 저장된다.

위의 그림에서 볼 수 있듯이 배열로 구성하기 때문에 A라는 그래프의 인스턴스명으로 가정했을 때, `A[3] = [2, 5]` 3번 노드는 2와 5번과 연결되어 있다. 이런식으로 표현이 가능하다.

가중치가 있는 [[유방향 그래프(Digraph(Directed graph)]]([[가중치 그래프(weighted graph)]])
: 종점 `[노드 번호 | 간선의 가중치]`(즉 노드 번호 간선 가중치의 객체를 생성하여 저장) 정보가 저장된다.

#### 무방향 [[에지 리스트(edge list)]]와 인접리스트의 차이점
예시) 노드 1과 노드 2가 연결되었다고 가정할 때

- **인접 리스트 (Adjacency List):** 이 방식은 각 노드(정점)를 기준으로 그 노드와 인접한 노드들의 목록을 저장한다. 무방향 그래프에서는 (1, 2)와 (2, 1)을 동일한 에지로 취급하므로, 무방향 그래프에서 각 에지가 두 번 나타나게 된다.

- **에지 리스트 (Edge List):** 에지 리스트 방식은 간선(에지)을 직접 저장한다. 따라서 (1, 2)라는 에지가 존재한다면 이 에지를 그대로 리스트에 추가한다. 이때 (2, 1)과 같이 역방향의 에지도 별도로 저장할 필요가 없다. 에지 리스트 방식은 그래프의 모든 에지를 한 번만 저장하므로 저장 공간 측면에서 효율적이다.

#### 무방향 에지리스트를 인접리스트로 바꾸는 코드
```python
edges = [[0,1],[1,2],[2,0]]

graph = {} # 무방향 인접 리스트로 바꾸기 위한 딕셔너리 초기화

for edge in edges: 
	u, v = edge # 시작 노드 끝 노드를 언패킹
	if u not in graph: # 노드 값이 그래프에 없으면 빈 값을 넣음
		graph[u] = [] 
	if v not in graph: 
		graph[v] = [] 
		
	graph[u].append(v) 
	graph[v].append(u)

# 실행결과
{ 
	0: [1, 2], 
	1: [0, 2], 
	2: [0, 1]
}
# 이러한 딕셔너리 형태의 무방향 인접 리스트가 생성됨
```



```python
V, E = map(int, input().split()) # 정점의 갯수와 간선의 갯수를 입력받음  
  
edge = list(map(int, input().split())) # 간선의 정보를 입력받음  
  
adj = [[] * (V + 1) for _ in range(V + 1)]
# 첫번쨰 인덱스 0을 무시하기 위해 정점 + 1 x 정점 + 1 갯수만큼 이차원 리스트를 초기화  
  
for i in range(E):  
    n1 = edge[i * 2] 
	# 첫번째 인덱스 0를 건너뛰고 받기 위해서 edge[0] edge[2] edge[4] edge[6] edge[8]
	
	n2 = edge[i * 2 + 1] 
	# 첫번째 인덱스 0를 건너뛰고 두번째 인덱스를 받기 위해서 edge[1] edge[3] edge[5] edge[7]
	
	adj[n1].append(n2) 
	# adk[edge[0]].append(edge[1]) 예시) 1 2 1 3 2 4 3 5 4 6 일때 두번쨰 리스트(1)에 2값을 넣음.  
    
    adj[n2].append(n1)  
  
print(adj)
```
