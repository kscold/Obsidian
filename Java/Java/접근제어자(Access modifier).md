- 접근제어자는 [[클래스(Class)]]의 [[멤버 변수]]와 [[메서드(Method)]]들의 접근 권한을 지정한다.

- 접근제어자의 종류는 4가지로 [[public]], protected, default, [[private]]이며,  접근 허용 가능 범위 순서 또한 아래와 같이 나타낼 수 있다.

[[public]] > protected > default > [[private]]

아래의 표로 접근 권한 범위를 자세하게 확인할 수 있습니다.(허용 : O, 제한 : X)

|  |  |  |  |  |
| ---- | ---- | ---- | ---- | ---- |
| **접근자** | 클래스 내부 | 패키지 | 상속받은 클래스 [[자식 클래스(sub class)]] | 이외의 영역 |
| private | O | X | X | X |
| default | O | O | X | X |
| protected | O | O | O | X |
| public | O | O | O | O |

- public : 접근 제한이 없다.
- protected : 동일한 패키지(package 형식 파일) 내에 존재하거나, 파생 클래스에서만 접근이 가능하다.
- default : 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능하다.
- private : 자기 자신의 클래스 내에서만 접근이 가능하다.

### 접근제어자를 사용하는 이유

애플리케이션이 커진다는 것은,  그만큼 문제점이 생길 확률도 커진다는 말이 된다. 
특히 로직이 망가지는 첫 번째 원인은 사용자라고 할 수 있다. 
즉, [[객체(Object)]]를 사용하는 입장에서 객체 내부적으로 사용하는 변수나 메소드에 접근함으로써 개발자가 의도하지 못한 오동작을 일으키기도 한다.

이러한 문제로부터 객체의 로직을 보호하기 위해서는 멤버에 따라서 외부의 접근을 허용하거나 차단해야 할 필요가 생긴다.

마치 은행이 누구나 접근할 수 있는 창구와 관계자 외에는 출입이 엄격하게 통제되는 금고를 구분하고 있는 이유와 같다.

접근제어자를 사용하는 또 다른 이유는 사용자에게 객체를 조작할 수 있는 수단만을 제공함으로써 결과적으로 객체의 사용에 집중할 수 있도록 돕기 위함이다.

즉, 의도치 않은 실수를 줄이기 위함과 정보 은닉([[캡슐화(encapsulation)]])의 목적으로 사용할 수 있다.