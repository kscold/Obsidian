- 그래프에서 사이클이 존재 하는지 유무를 판단한는 알고리즘이다.
- 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지 확인하는 find 연산으로 구성되어 있다
- 항상 대표노드(최종적인 노드, base case와 비슷)끼리만 연결한다.

#### 유니온 파인드의 원리 이해하기 
![[Pasted image 20231030194032.png]]

1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다. 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표노드(결과적인 노드)가 된다.
2. 2개의 노드를 선택해 각각에 대표 노드를 찾아 연결하는 union연산을 수행한다.

![[Pasted image 20231030194326.png]]
3. 그래프에서 union(1, 4)라는 뜻은 노드 1과 노드 4를 연결한다는 뜻과 같으므로 유니온 파인드 배열에 대표노드를 위와 같이 수정할 수 있다.
4. 따라서 이후 union(4, 6)이라는 경우가 생겼을 때는, 이전에 union(1, 4)와 union(5, 6)에서 계산된 배열의 대표 노드인 1 과 5 가 연결되어 있다는 것 과 같으므로 5번 인덱스의 값에는 1이라는 노드의 값이 들어가게 된다. -> 이런 방식을 find 연산이라고 한다.


#### find 연산
- 자신이 속한 집합의 대표노드를 찾는 연산이다.
- find 연산은 단순히 대표 노드만 찾는 역할을 하는 것은 아니고, 그래프를 정돈하고 시간복잡도를 향상시킨다.

find 연산의 작동원리
1. 대상 노드의 index 값과 value값이 동일한지 확인한다.
2. 동일하지 않으면 value값이 가리키는 index 위치로 이동한다.
3. 이동 위치의 index 값과 value 값이 같을 때까지 1과 2번을 반복한다. 반복이므로 이부분은 [[재귀함수(Recursive Function)]]로 구현한다.
4. 대표 노드에 도달하면 재귀함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다. -> 이 부분이 매우 중요한데 메모이제이션과 같은 방식으로 시간복잡도를 O(1)로 줄일 수 있어서 무조건 해주는 것이 좋다.

![[Pasted image 20231030195946.png]]

