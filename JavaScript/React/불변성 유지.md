- 리액트에서 상태([[state]])를 업데이트할 때는 기존 상태를 그대로 두면서 새로우 값을 상태로 설정해야 한다.
- 불변성 유지를 해 주어야 나중에 리액트 [[컴포넌트(component)]]의 성능을 최적화할 수 있다.


- 원시타입은 불변성을 가지고 있다.(값을 변경할 수 없다는 이야기가 아니다.)
- 대표적인 원시타입인 [[let]] string 타입을 통해 예를 들어보자.

```javascript
let string = 'data1' 
string = 'data2'
```

- 변수 string은 data1 -> data2로 값이 변경되었다.
- 사실 위 문장은 반은 맞고 반은 틀리다.
- 위 예시를 보면  string 변수는 'data1' → 'data2' 로 값이 변경된 것처럼 보이지만 실제 메모리영역에는 'data1', 'data2' 둘다 존재한다.
- 메모리 영역이 1~10영역까지 10개가 있다고 가정해볼게요.

```javascript
let string = 'data1' // 1. string: 'data1'가 메모리 영역1에 등록됩니다. 
string = 'data2' // 2. string: 'data2'가 메모리 영역2에 등록됩니다.
```

위 예시에서 메모리 영역을 총 2개 사용했습니다.

변수 string은 'data1' 였고, 여기에 'data2'를 재할당하였는데

기존 메모리 영역 1에 있는 'data1'의 값은 그대로 두고,

메모리 영역2에 'data2'를 새로 할당했습니다.

즉, 메모리영역에서 'data2'는 'data1'을 대체하는 것이 아니라 새로운 영역에 할당됩니다.

이게 불변성입니다. 

이번엔 참조 타입을 통해서 불변성에 대해 알아보겠습니다.

```javascript
let array = [1, 2, 3, 4] // 메모리영역 1
array.push(5) // 메모리영역 1 

array = [1, 2, 3, 4] // 메모리영역 2 (새로운 참조값)
```

array.push(5)는 원본 배열을 수정하면서 불변성을 지키지 않고 있고, array = [1, 2, 3, 4]는 원본 배열을 수정하는게 아니라 새 참조값을 가진 새로운 배열 [1, 2, 3, 4]을 할당하여 불변성을 지켜주고 있습니다.

정리하자면,

_"불변성의 진짜 의미는 **메모리 영역에서 값이 변하지 않는다** 라는 의미입니다."_